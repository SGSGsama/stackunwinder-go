// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64 || wasm

package stackunwinder

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type probes_SysEnterDataNoStack struct {
	_         structs.HostLayout
	Regs      [31]uint64
	Pc        uint64
	Sp        uint64
	Comm      [32]uint8
	ArgBuf    [3][512]uint8
	SyscallId uint64
	Tid       uint32
	_         [4]byte
	SigState  int64
}

// loadProbes_ returns the embedded CollectionSpec for probes_.
func loadProbes_() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Probes_Bytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load probes_: %w", err)
	}

	return spec, err
}

// loadProbes_Objects loads probes_ and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*probes_Objects
//	*probes_Programs
//	*probes_Maps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadProbes_Objects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadProbes_()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// probes_Specs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type probes_Specs struct {
	probes_ProgramSpecs
	probes_MapSpecs
	probes_VariableSpecs
}

// probes_ProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type probes_ProgramSpecs struct {
	SysEnter *ebpf.ProgramSpec `ebpf:"sys_enter"`
}

// probes_MapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type probes_MapSpecs struct {
	StackBaseAddrTable *ebpf.MapSpec `ebpf:"stackBaseAddrTable"`
	SysEnterRb         *ebpf.MapSpec `ebpf:"sysEnterRb"`
	TargetSyscalls     *ebpf.MapSpec `ebpf:"targetSyscalls"`
	TidStateMap        *ebpf.MapSpec `ebpf:"tidStateMap"`
}

// probes_VariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type probes_VariableSpecs struct {
	CLONE                   *ebpf.VariableSpec `ebpf:"CLONE"`
	CLONE3                  *ebpf.VariableSpec `ebpf:"CLONE3"`
	EXECVE                  *ebpf.VariableSpec `ebpf:"EXECVE"`
	EXECVEAT                *ebpf.VariableSpec `ebpf:"EXECVEAT"`
	FNV_64INIT              *ebpf.VariableSpec `ebpf:"FNV_64_INIT"`
	FNV_64PRIME             *ebpf.VariableSpec `ebpf:"FNV_64_PRIME"`
	GETRANDOM               *ebpf.VariableSpec `ebpf:"GETRANDOM"`
	NEWFSTATAT              *ebpf.VariableSpec `ebpf:"NEWFSTATAT"`
	OPENAT                  *ebpf.VariableSpec `ebpf:"OPENAT"`
	OPENAT2                 *ebpf.VariableSpec `ebpf:"OPENAT2"`
	PREAD64                 *ebpf.VariableSpec `ebpf:"PREAD64"`
	PTRACE                  *ebpf.VariableSpec `ebpf:"PTRACE"`
	PWRITE64                *ebpf.VariableSpec `ebpf:"PWRITE64"`
	READ                    *ebpf.VariableSpec `ebpf:"READ"`
	READLINKAT              *ebpf.VariableSpec `ebpf:"READLINKAT"`
	WRITE                   *ebpf.VariableSpec `ebpf:"WRITE"`
	Aarch64SyscallArgsCount *ebpf.VariableSpec `ebpf:"aarch64_syscall_args_count"`
	TargetPid               *ebpf.VariableSpec `ebpf:"targetPid"`
}

// probes_Objects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadProbes_Objects or ebpf.CollectionSpec.LoadAndAssign.
type probes_Objects struct {
	probes_Programs
	probes_Maps
	probes_Variables
}

func (o *probes_Objects) Close() error {
	return _Probes_Close(
		&o.probes_Programs,
		&o.probes_Maps,
	)
}

// probes_Maps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadProbes_Objects or ebpf.CollectionSpec.LoadAndAssign.
type probes_Maps struct {
	StackBaseAddrTable *ebpf.Map `ebpf:"stackBaseAddrTable"`
	SysEnterRb         *ebpf.Map `ebpf:"sysEnterRb"`
	TargetSyscalls     *ebpf.Map `ebpf:"targetSyscalls"`
	TidStateMap        *ebpf.Map `ebpf:"tidStateMap"`
}

func (m *probes_Maps) Close() error {
	return _Probes_Close(
		m.StackBaseAddrTable,
		m.SysEnterRb,
		m.TargetSyscalls,
		m.TidStateMap,
	)
}

// probes_Variables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadProbes_Objects or ebpf.CollectionSpec.LoadAndAssign.
type probes_Variables struct {
	CLONE                   *ebpf.Variable `ebpf:"CLONE"`
	CLONE3                  *ebpf.Variable `ebpf:"CLONE3"`
	EXECVE                  *ebpf.Variable `ebpf:"EXECVE"`
	EXECVEAT                *ebpf.Variable `ebpf:"EXECVEAT"`
	FNV_64INIT              *ebpf.Variable `ebpf:"FNV_64_INIT"`
	FNV_64PRIME             *ebpf.Variable `ebpf:"FNV_64_PRIME"`
	GETRANDOM               *ebpf.Variable `ebpf:"GETRANDOM"`
	NEWFSTATAT              *ebpf.Variable `ebpf:"NEWFSTATAT"`
	OPENAT                  *ebpf.Variable `ebpf:"OPENAT"`
	OPENAT2                 *ebpf.Variable `ebpf:"OPENAT2"`
	PREAD64                 *ebpf.Variable `ebpf:"PREAD64"`
	PTRACE                  *ebpf.Variable `ebpf:"PTRACE"`
	PWRITE64                *ebpf.Variable `ebpf:"PWRITE64"`
	READ                    *ebpf.Variable `ebpf:"READ"`
	READLINKAT              *ebpf.Variable `ebpf:"READLINKAT"`
	WRITE                   *ebpf.Variable `ebpf:"WRITE"`
	Aarch64SyscallArgsCount *ebpf.Variable `ebpf:"aarch64_syscall_args_count"`
	TargetPid               *ebpf.Variable `ebpf:"targetPid"`
}

// probes_Programs contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadProbes_Objects or ebpf.CollectionSpec.LoadAndAssign.
type probes_Programs struct {
	SysEnter *ebpf.Program `ebpf:"sys_enter"`
}

func (p *probes_Programs) Close() error {
	return _Probes_Close(
		p.SysEnter,
	)
}

func _Probes_Close(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed probes__bpfel.o
var _Probes_Bytes []byte
